<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>dp_policy.titlei.allocators API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>dp_policy.titlei.allocators</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L1-L646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">from dp_policy.titlei.utils import \
    weighting
from dp_policy.titlei.thresholders import Threshold, HardThresholder

import numpy as np
import pandas as pd

from typing import Tuple, List


class Allocator:
    def __init__(
        self,
        estimates: pd.DataFrame,
        prefixes: Tuple[str] = (&#34;true&#34;, &#34;est&#34;, &#34;dp&#34;, &#34;dpest&#34;),
        congress_cap: float = 0.4,
        adj_sppe_bounds: List[float] = [0.32, 0.48],
        adj_sppe_bounds_efig: List[float] = [0.34, 0.46],
        appropriation: float = None,
        verbose: bool = False
    ):
        &#34;&#34;&#34;Class for allocating Title I funds.

        Args:
            estimates (pd.DataFrame): The poverty estimates, including
                randomized estimates.
            prefixes (Tuple[str], optional): Prefixes for different kinds of
                estimates. Defaults to (&#34;true&#34;, &#34;est&#34;, &#34;dp&#34;, &#34;dpest&#34;).
            congress_cap (float, optional): Congressional cap. Defaults to 0.4.
            adj_sppe_bounds (List[float], optional): Bounds on adjusted SPPE.
                Defaults to [0.32, 0.48].
            adj_sppe_bounds_efig (List[float], optional): Bounds on adjusted
                SPPE for EFIG grants. Defaults to [0.34, 0.46].
            appropriation (float, optional): Total congressional appropriation.
                Defaults to None.
            verbose (bool, optional): Defaults to False.
        &#34;&#34;&#34;
        self.estimates = estimates
        self.prefixes = prefixes
        self.congress_cap = congress_cap
        self.adj_sppe_bounds = adj_sppe_bounds
        self.adj_sppe_bounds_efig = adj_sppe_bounds_efig
        self.appropriation_total = appropriation
        self.verbose = verbose

    def allocations(
        self,
        normalize: bool = False
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Compute allocations.

        Args:
            normalize (bool, optional): Whether to normalize the authorization
                amounts. Defaults to False.

        Returns:
            pd.DataFrame: Estimates dataframe with computed allocations added.
        &#34;&#34;&#34;
        self.calc_auth()
        if normalize:
            self.normalize()
        return self.estimates

    def calc_auth(self):
        &#34;&#34;&#34;
        Appends the allocated grants as columns to the estimates DataFrame.

        Must generate at least `true_grant_total` and `est_grant_total`.

        returns:
            pd.DataFrame: current estimates
        &#34;&#34;&#34;
        raise NotImplementedError

    def normalize(self):
        &#34;&#34;&#34;Normalize authorization amounts to allocation amounts.
        &#34;&#34;&#34;

    def adj_sppe(self):
        &#34;&#34;&#34;Calculate adjusted SPPE using Sonnenberg, 2016 pg. 18 algorithm.
        &#34;&#34;&#34;
        # Get baseline average across all 50 states and territories
        average = np.round(
            self.estimates.sppe.groupby(&#34;State FIPS Code&#34;).first().mean(),
            decimals=2
        )
        # Each state’s and each territory’s SPPE is multiplied by the
        # congressional cap and rounded to the second decimal place
        # (for dollars and cents).
        scaled = np.round(self.estimates.sppe * self.congress_cap, decimals=2)
        # No state recieves above/below the bounds set by law
        adj_sppe_trunc = scaled.clip(
            # bound by some % of the average, given in the law - round to cents
            *np.round(np.array(self.adj_sppe_bounds)*average, decimals=2)
        )
        adj_sppe_efig = scaled.clip(
            # bound %s are different for EFIG
            *np.round(np.array(self.adj_sppe_bounds_efig)*average, decimals=2)
        )
        return adj_sppe_trunc, adj_sppe_efig


class AbowdAllocator(Allocator):
    &#34;&#34;&#34;
    As described in https://arxiv.org/pdf/1808.06303.pdf
    &#34;&#34;&#34;
    def grant_types(self):
        return (
            &#34;total&#34;
        )

    def calc_auth(self):
        adj_sppe, _ = self.adj_sppe()

        self.estimates[&#34;adj_sppe&#34;] = adj_sppe
        for prefix in self.prefixes:
            self.estimates[f&#34;{prefix}_grant_total&#34;] = \
                adj_sppe * self.estimates[f&#34;{prefix}_children_eligible&#34;]

        return self.estimates


class Authorizer(Allocator):
    &#34;&#34;&#34;An allocator that uses a normalization strategy to convert
    authorization amounts to allocation amounts.
    &#34;&#34;&#34;
    def grant_types(self):
        raise NotImplementedError

    def calc_total(self):
        for prefix in self.prefixes:
            self.estimates[f&#34;{prefix}_grant_total&#34;] = self.estimates[[
                f&#34;{prefix}_grant_{grant_type}&#34;
                for grant_type in self.grant_types()
            ]].sum(axis=1)
        return self.estimates

    def allocations(
        self, normalize=True, **kwargs
    ) -&gt; pd.DataFrame:
        super().allocations(**kwargs)
        if normalize:
            for grant_type in self.grant_types():
                for prefix in self.prefixes:
                    appropriation = \
                        self._calc_appropriation_total(grant_type)
                    self._normalize(grant_type, prefix, appropriation)
            self.calc_total()
            if self.verbose:
                total_approp = self.estimates[[
                    f&#34;official_{grant_type}_alloc&#34;
                    for grant_type in self.grant_types()
                ]].sum().sum()
                print(
                    &#34;After normalization, appropriation is&#34;,
                    total_approp,
                    &#34;and true allocation is&#34;,
                    self.estimates.true_grant_total.sum()
                )
        return self.estimates

    def _calc_appropriation_total(
        self,
        grant_type: str
    ) -&gt; float:
        &#34;&#34;&#34;Using official figures, calculate appropriation for this grant type.

        Args:
            grant_type (str): The grant type. One of &#34;basic&#34;, &#34;concentration&#34;,
                &#34;targeted&#34;.

        Returns:
            float: The total appropration for this grant type.
        &#34;&#34;&#34;
        appropriation = self.estimates[f&#34;official_{grant_type}_alloc&#34;].sum()
        if self.appropriation_total is not None:
            if self.verbose:
                print(&#34;Usual appropriation:&#34;, appropriation)
                print(
                    &#34;Usual total:&#34;,
                    self.estimates[f&#34;official_total_alloc&#34;].sum()
                )
                print(
                    self.appropriation_total /
                    self.estimates[f&#34;official_total_alloc&#34;].sum()
                )
                print(&#34;New appropriation:&#34;, (
                    appropriation * self.appropriation_total /
                    self.estimates[f&#34;official_total_alloc&#34;].sum()
                ))
            # scale appropriation to total budget
            return (
                appropriation * self.appropriation_total /
                self.estimates[f&#34;official_total_alloc&#34;].sum()
            )
        return appropriation

    def _normalize(
        self,
        grant_type: str,
        prefix: str,
        appropriation: float,
        hold_harmless: pd.Series = None,
        state_minimum: bool = False
    ):
        &#34;&#34;&#34;Normalize funding amounts, honoring special provisions.

        Args:
            grant_type (str):  The grant type. One of &#34;basic&#34;, &#34;concentration&#34;,
                &#34;targeted&#34;.
            prefix (str): Prefix for estimate. One of
                (&#34;true&#34;, &#34;est&#34;, &#34;dp&#34;, &#34;dpest&#34;).
            appropriation (float): The total appropriation available.
            hold_harmless (pd.DataFrame, optional): If provided, which
                districts are held harmless. Defaults to None.
            state_minimum (bool, optional): Whether to apply the state minimum.
                Defaults to False.
        &#34;&#34;&#34;
        if hold_harmless is None:
            hold_harmless = np.zeros(len(self.estimates)).astype(bool)

        current_budget = \
            self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;].sum()

        # do a round of hold harmless normalization
        # (to get the alloc instead of auth amounts)
        self._normalize_segment(
                np.ones(len(self.estimates)).astype(bool),
                hold_harmless,
                grant_type, prefix,
                appropriation
            )

        if state_minimum:
            glob_min = \
                SonnenbergAuthorizer._state_minimum_global(grant_type)
            formula_children = self.estimates[f&#34;{prefix}_children_eligible&#34;]\
                .where(
                    self.estimates[f&#34;{prefix}_eligible_{grant_type}&#34;],
                    0
                )
            state_eligible = formula_children\
                .groupby(&#34;State FIPS Code&#34;).transform(&#39;sum&#39;)
            # nat&#39;l avg per-pupil payment (???)
            napp = appropriation \
                / self.estimates[f&#34;{prefix}_children_total&#34;].sum()
            eligib_comp = state_eligible * 1.5 * napp
            if grant_type == &#34;concentration&#34;:
                # for concentration, this amount is at minimum 340000
                eligib_comp = np.clip(eligib_comp, 340000, None)

            # the state minimum is the smaller of
            state_minimums = np.minimum(
                # 1) the global minimum - derived from the official
                # FY 2021 state allocs
                np.ones(len(self.estimates)) * glob_min,
                # and 2) the average of
                1/2 * (
                    # a) global minimum and
                    # b) the state&#39;s elibility count * 1.5 * avg SPPE
                    glob_min + eligib_comp
                )
            )
            # identify LEAs in states under the minimum
            under_minimum = self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;]\
                .groupby(&#34;State FIPS Code&#34;).transform(&#39;sum&#39;) &lt; state_minimums
            if self.verbose:
                print(
                    &#34;These states meet the state minimum:&#34;,
                    np.unique(
                        under_minimum[under_minimum].index
                        .get_level_values(&#34;State FIPS Code&#34;).values
                    )
                )

            # first, normalize all the over-minimum states
            total_minimum = state_minimums[under_minimum]\
                .groupby(&#34;State FIPS Code&#34;).first().sum()
            self._normalize_segment(
                ~under_minimum,
                hold_harmless,
                grant_type, prefix,
                appropriation - total_minimum
            )

            # then normalize the under-minimum states, state-by-state
            for _, group in self.estimates[under_minimum].groupby(
                &#34;State FIPS Code&#34;
            ):
                minimum = state_minimums[group.index].iloc[0]
                self._normalize_segment(
                    self.estimates.index.isin(group.index),
                    hold_harmless,
                    grant_type, prefix,
                    minimum
                )

        if self.verbose:
            print(
                f&#34;{current_budget} authorized for {grant_type} reduced &#34;
                f&#34;to {appropriation} allocated.&#34;
            )

    def _normalize_segment(
        self,
        segment: pd.Series,
        hold_harmless: pd.Series,
        grant_type: str,
        prefix: str,
        segment_appropriation: float
    ):
        &#34;&#34;&#34;Normalize the budget for a segment of the districts.

        Args:
            segment (pd.Series): A boolean mask indicating the segment to
                normalize.
            hold_harmless (pd.Series): Which districts should be held harmless.
            grant_type (str): Grant type to normalize.
            prefix (str): Which treatment to normalize (generally &#34;true&#34;,
                &#34;est&#34; or &#34;dpest&#34;).
            segment_appropriation (float): The total budget for this segment.
        &#34;&#34;&#34;
        # available budget is the full budget minus hold harmless districts
        remaining_budget = segment_appropriation - self.estimates.loc[
                segment &amp; hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
            ].sum()
        # redistribute the remaining budget between non-harmless districts
        self.estimates.loc[
            segment &amp; ~hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
        ] = \
            Authorizer.normalize_to_budget(
                self.estimates.loc[
                    segment &amp; ~hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
                ], remaining_budget
            )

    @staticmethod
    def normalize_to_budget(
        authorizations: pd.Series,
        total_budget: int
    ) -&gt; pd.Series:
        &#34;&#34;&#34;Scale authorizations proportional to total federal budget.

        Args:
            authorizations (pd.Series): Authorization amounts.
            total_budget (int): Estimated total budget for Title I this year.

        Returns:
            pd.Series: Normalized authorization amounts.
        &#34;&#34;&#34;
        return authorizations / authorizations.sum() * total_budget


class SonnenbergAuthorizer(Authorizer):
    &#34;&#34;&#34;Authorizer allocator described by Sonnenberg (2007). Official process
    used by Dep Ed.
    &#34;&#34;&#34;
    def __init__(
        self,
        *args,
        **kwargs
    ):
        self.hold_harmless = kwargs.pop(&#39;hold_harmless&#39;, False)
        self.state_minimum = kwargs.pop(&#39;state_minimum&#39;, False)
        self.thresholder = kwargs.pop(&#39;thresholder&#39;, HardThresholder())
        super().__init__(*args, **kwargs)
        if self.state_minimum and self.verbose:
            print(
                &#34;[WARN] State minimum works using 2021 data. &#34;
                &#34;Will be wrong for earlier years.&#34;
            )

    def allocations(
        self, **kwargs
    ) -&gt; pd.DataFrame:
        super().allocations(**kwargs)
        if self.hold_harmless or self.state_minimum:
            self._provisions()
        return self.estimates

    def grant_types(self):
        return (
            &#34;basic&#34;,
            &#34;concentration&#34;,
            &#34;targeted&#34;
        )

    def calc_auth(self):
        # calc adj. SPPE
        adj_sppe, _ = self.adj_sppe()
        self.thresholder.set_cv(self.estimates.cv)

        # calculate grant amounts for true/randomized values
        for prefix in self.prefixes:
            # BASIC GRANTS
            # authorization calculation
            self.estimates[f&#34;{prefix}_grant_basic&#34;] = \
                self.estimates[f&#34;{prefix}_children_eligible&#34;] * adj_sppe
            # For basic grants, LEA must have
            # &gt;10 eligible children
            # AND &gt;2% eligible
            grants, eligible = \
                self.thresholder.process(
                    self.estimates[f&#34;{prefix}_grant_basic&#34;],
                    self.estimates[f&#34;{prefix}_children_eligible&#34;],
                    self.estimates[f&#34;{prefix}_children_total&#34;],
                    [
                        Threshold(10, prop=False),
                        Threshold(0.02, prop=True)
                    ],
                    comb_func=np.logical_and.reduce
                )
            self.estimates.loc[:, f&#34;{prefix}_grant_basic&#34;] = grants
            self.estimates.loc[:, f&#34;{prefix}_eligible_basic&#34;] = eligible

            # CONCENTRATION GRANTS
            # For concentration grants, LEAs must meet basic eligibility
            # AND have either
            # a) &gt;6500 eligible
            # b) 15% of pop. is eligible
            self.estimates[f&#34;{prefix}_grant_concentration&#34;] = \
                self.estimates[f&#34;{prefix}_grant_basic&#34;]
            grants, eligible = \
                self.thresholder.process(
                    self.estimates[f&#34;{prefix}_grant_concentration&#34;],
                    self.estimates[f&#34;{prefix}_children_eligible&#34;],
                    self.estimates[f&#34;{prefix}_children_total&#34;],
                    [
                        Threshold(6500, prop=False),
                        Threshold(0.15, prop=True)
                    ],
                    comb_func=lambda x:
                        self.estimates[f&#34;{prefix}_eligible_basic&#34;]
                        &amp; np.logical_or.reduce(x)
                )
            self.estimates.loc[:, f&#34;{prefix}_grant_concentration&#34;] = grants
            self.estimates.loc[:, f&#34;{prefix}_eligible_concentration&#34;] = \
                eligible

            # TARGETED GRANTS
            # weighted by an exogenous step function - see documentation
            weighted_eligible = self.estimates[[
                f&#34;{prefix}_children_eligible&#34;, f&#34;{prefix}_children_total&#34;
            ]].apply(
                lambda x: weighting(x[0], x[1]),
                axis=1
            )
            self.estimates[
                f&#34;{prefix}_grant_targeted&#34;
            ] = weighted_eligible * adj_sppe
            # for targeted grants, LEAs must:
            # meet basic eligibility AND have &gt;5% eligible
            grants, eligible = \
                self.thresholder.process(
                    self.estimates[f&#34;{prefix}_grant_targeted&#34;],
                    self.estimates[f&#34;{prefix}_children_eligible&#34;],
                    self.estimates[f&#34;{prefix}_children_total&#34;],
                    [
                        Threshold(10, prop=False),
                        Threshold(0.05, prop=True)
                    ],
                    comb_func=np.logical_and.reduce
                )
            self.estimates.loc[:, f&#34;{prefix}_grant_targeted&#34;] = grants
            self.estimates.loc[:, f&#34;{prefix}_eligible_targeted&#34;] = eligible

            # EFIG
            # TODO

            # clip lower bound to zero
            for grant_type in [&#34;basic&#34;, &#34;concentration&#34;, &#34;targeted&#34;]:
                self.estimates.loc[
                    self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;] &lt; 0.0,
                    f&#34;{prefix}_grant_{grant_type}&#34;
                ] = 0.0

        self.calc_total()

    def _provisions(self):
        &#34;&#34;&#34;
        Apply post-formula provisions (hold harmless and state minimum).
        Achieved by recursively updating allocations until all provisions are
        satisfied.
        &#34;&#34;&#34;
        if self.verbose:
            if self.hold_harmless:
                print(&#34;Applying hold harmless&#34;)
            if self.state_minimum:
                print(&#34;Applying state minimum&#34;)

        # load last year&#39;s allocs - watch out for endogeneity
        # get this year&#39;s budget
        for grant_type in self.grant_types():
            alloc_previous = \
                self.estimates[f&#34;official_{grant_type}_hold_harmless&#34;]
            appropriation = self._calc_appropriation_total(grant_type)
            for prefix in self.prefixes:
                # hold harmless
                self._harmless_rate = SonnenbergAuthorizer._hold_harmless_rate(
                    self.estimates[f&#34;{prefix}_children_eligible&#34;] /
                    self.estimates[f&#34;{prefix}_children_total&#34;]
                )
                self._provisions_recursive(
                    0,
                    prefix,
                    grant_type,
                    appropriation,
                    alloc_previous
                )

        self.calc_total()
        if self.verbose:
            total_approp = self.estimates[[
                f&#34;official_{grant_type}_alloc&#34;
                for grant_type in self.grant_types()
            ]].sum().sum()
            print(
                &#34;After provision(s), appropriation is&#34;,
                total_approp,
                &#34;and true allocation is&#34;,
                self.estimates.true_grant_total.sum()
            )

    def _provisions_recursive(
        self,
        depth: int,
        prefix: str,
        grant_type: str,
        appropriation: float,
        alloc_previous: pd.Series,
        held_harmless: bool = None,
        max_depth: int = 10
    ):
        &#34;&#34;&#34;Apply one iteration of post-formula provisions.

        Args:
            depth (int): Current iteration of recursion.
            prefix (str): Prefix of allocation to adjust.
            grant_type (str): Grant type to adjust.
            appropriation (float): Appropriation for this grant type.
            alloc_previous (pd.Series): Previous year&#39;s allocations.
            held_harmless (bool, optional): Boolena mask for districts to hold
                harmless. Defaults to None.
            max_depth (int, optional): Maximum number of iterations to run
                before stopping. Defaults to 10.
        &#34;&#34;&#34;
        # assume no LEAs in violation of provisions
        leas_in_violation = np.zeros(len(self.estimates)).astype(bool)

        if self.hold_harmless:
            if held_harmless is None:
                held_harmless = np.zeros(len(self.estimates)).astype(bool)
            # identify LEAs suffering excessive harm
            hold_harmless = self._excessive_loss(
                prefix, grant_type, alloc_previous, self._harmless_rate
            )
            if self.verbose and depth &gt; 0:
                print(
                    &#34;Hold harmless iter&#34;, depth,
                    f&#34;- {hold_harmless.sum()} hold harm districts remaining&#34;
                )
            # limit losses to the appropriate harmless rate
            if hold_harmless.any():
                held_harmless = held_harmless | hold_harmless
                leas_in_violation = leas_in_violation | hold_harmless
                self.estimates.loc[
                    hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
                ] = alloc_previous * self._harmless_rate
                self._normalize(
                    grant_type, prefix, appropriation,
                    hold_harmless=held_harmless,
                    state_minimum=self.state_minimum
                )
        else:
            self._normalize(
                grant_type, prefix, appropriation,
                state_minimum=self.state_minimum
            )

        # once no LEAs are in violation, finish
        if not leas_in_violation.any():
            return

        if depth &gt;= max_depth:
            if self.hold_harmless:
                print(f&#34;[WARN]: {hold_harmless.sum()} not held harmless.&#34;)
            print(
                f&#34;[WARN] Could not converge after {max_depth} iterations.&#34;
            )
            return

        return self._provisions_recursive(
            depth+1,
            prefix,
            grant_type,
            appropriation,
            alloc_previous,
            held_harmless=held_harmless,
            max_depth=max_depth
        )

    def _excessive_loss(
        self,
        prefix: str,
        grant_type: str,
        alloc_previous: pd.Series,
        harmless_rate: pd.Series
    ) -&gt; pd.Series:
        &#34;&#34;&#34;Determine whether a district has suffered excessive loss.

        Returns:
            pd.Series: Boolean mask for each district indicating whether it
                has suffered excessive loss compared to the previous
                year&#39;s allocation.
        &#34;&#34;&#34;
        return (
            self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;] &lt;
            harmless_rate * alloc_previous
        )

    @staticmethod
    def _hold_harmless_rate(prop_eligible: pd.Series) -&gt; np.ndarray:
        &#34;&#34;&#34;Determine the hold harmless rate for a district based on the
        proportion of eligible children.
        &#34;&#34;&#34;
        return np.where(
            prop_eligible &lt; 0.15,
            0.85,
            np.where(
                prop_eligible &lt; 0.3,
                0.9,
                0.95
            )
        )

    @staticmethod
    def _state_minimum_global(grant_type: str) -&gt; int:
        # drawing this manually from the FY 2021 state-level data
        # NOTE: only works for 2021 data
        if grant_type == &#34;basic&#34;:
            return 17744098
        if grant_type == &#34;concentration&#34;:
            return 3378479
        if grant_type == &#34;targeted&#34;:
            return 15083659
        raise ValueError(f&#34;Unmatched grant type: {grant_type}&#34;)</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="dp_policy.titlei.allocators.AbowdAllocator"><code class="flex name class">
<span>class <span class="ident">AbowdAllocator</span></span>
<span>(</span><span>estimates: pandas.core.frame.DataFrame, prefixes: Tuple[str] = ('true', 'est', 'dp', 'dpest'), congress_cap: float = 0.4, adj_sppe_bounds: List[float] = [0.32, 0.48], adj_sppe_bounds_efig: List[float] = [0.34, 0.46], appropriation: float = None, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>As described in <a href="https://arxiv.org/pdf/1808.06303.pdf">https://arxiv.org/pdf/1808.06303.pdf</a></p>
<p>Class for allocating Title I funds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The poverty estimates, including
randomized estimates.</dd>
<dt><strong><code>prefixes</code></strong> :&ensp;<code>Tuple[str]</code>, optional</dt>
<dd>Prefixes for different kinds of
estimates. Defaults to ("true", "est", "dp", "dpest").</dd>
<dt><strong><code>congress_cap</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Congressional cap. Defaults to 0.4.</dd>
<dt><strong><code>adj_sppe_bounds</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted SPPE.
Defaults to [0.32, 0.48].</dd>
<dt><strong><code>adj_sppe_bounds_efig</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted
SPPE for EFIG grants. Defaults to [0.34, 0.46].</dd>
<dt><strong><code>appropriation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total congressional appropriation.
Defaults to None.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L103-L120" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class AbowdAllocator(Allocator):
    &#34;&#34;&#34;
    As described in https://arxiv.org/pdf/1808.06303.pdf
    &#34;&#34;&#34;
    def grant_types(self):
        return (
            &#34;total&#34;
        )

    def calc_auth(self):
        adj_sppe, _ = self.adj_sppe()

        self.estimates[&#34;adj_sppe&#34;] = adj_sppe
        for prefix in self.prefixes:
            self.estimates[f&#34;{prefix}_grant_total&#34;] = \
                adj_sppe * self.estimates[f&#34;{prefix}_children_eligible&#34;]

        return self.estimates</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dp_policy.titlei.allocators.Allocator" href="#dp_policy.titlei.allocators.Allocator">Allocator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dp_policy.titlei.allocators.AbowdAllocator.grant_types"><code class="name flex">
<span>def <span class="ident">grant_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L107-L110" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grant_types(self):
    return (
        &#34;total&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dp_policy.titlei.allocators.Allocator" href="#dp_policy.titlei.allocators.Allocator">Allocator</a></b></code>:
<ul class="hlist">
<li><code><a title="dp_policy.titlei.allocators.Allocator.adj_sppe" href="#dp_policy.titlei.allocators.Allocator.adj_sppe">adj_sppe</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.allocations" href="#dp_policy.titlei.allocators.Allocator.allocations">allocations</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.calc_auth" href="#dp_policy.titlei.allocators.Allocator.calc_auth">calc_auth</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.normalize" href="#dp_policy.titlei.allocators.Allocator.normalize">normalize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dp_policy.titlei.allocators.Allocator"><code class="flex name class">
<span>class <span class="ident">Allocator</span></span>
<span>(</span><span>estimates: pandas.core.frame.DataFrame, prefixes: Tuple[str] = ('true', 'est', 'dp', 'dpest'), congress_cap: float = 0.4, adj_sppe_bounds: List[float] = [0.32, 0.48], adj_sppe_bounds_efig: List[float] = [0.34, 0.46], appropriation: float = None, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>Class for allocating Title I funds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The poverty estimates, including
randomized estimates.</dd>
<dt><strong><code>prefixes</code></strong> :&ensp;<code>Tuple[str]</code>, optional</dt>
<dd>Prefixes for different kinds of
estimates. Defaults to ("true", "est", "dp", "dpest").</dd>
<dt><strong><code>congress_cap</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Congressional cap. Defaults to 0.4.</dd>
<dt><strong><code>adj_sppe_bounds</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted SPPE.
Defaults to [0.32, 0.48].</dd>
<dt><strong><code>adj_sppe_bounds_efig</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted
SPPE for EFIG grants. Defaults to [0.34, 0.46].</dd>
<dt><strong><code>appropriation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total congressional appropriation.
Defaults to None.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L11-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Allocator:
    def __init__(
        self,
        estimates: pd.DataFrame,
        prefixes: Tuple[str] = (&#34;true&#34;, &#34;est&#34;, &#34;dp&#34;, &#34;dpest&#34;),
        congress_cap: float = 0.4,
        adj_sppe_bounds: List[float] = [0.32, 0.48],
        adj_sppe_bounds_efig: List[float] = [0.34, 0.46],
        appropriation: float = None,
        verbose: bool = False
    ):
        &#34;&#34;&#34;Class for allocating Title I funds.

        Args:
            estimates (pd.DataFrame): The poverty estimates, including
                randomized estimates.
            prefixes (Tuple[str], optional): Prefixes for different kinds of
                estimates. Defaults to (&#34;true&#34;, &#34;est&#34;, &#34;dp&#34;, &#34;dpest&#34;).
            congress_cap (float, optional): Congressional cap. Defaults to 0.4.
            adj_sppe_bounds (List[float], optional): Bounds on adjusted SPPE.
                Defaults to [0.32, 0.48].
            adj_sppe_bounds_efig (List[float], optional): Bounds on adjusted
                SPPE for EFIG grants. Defaults to [0.34, 0.46].
            appropriation (float, optional): Total congressional appropriation.
                Defaults to None.
            verbose (bool, optional): Defaults to False.
        &#34;&#34;&#34;
        self.estimates = estimates
        self.prefixes = prefixes
        self.congress_cap = congress_cap
        self.adj_sppe_bounds = adj_sppe_bounds
        self.adj_sppe_bounds_efig = adj_sppe_bounds_efig
        self.appropriation_total = appropriation
        self.verbose = verbose

    def allocations(
        self,
        normalize: bool = False
    ) -&gt; pd.DataFrame:
        &#34;&#34;&#34;Compute allocations.

        Args:
            normalize (bool, optional): Whether to normalize the authorization
                amounts. Defaults to False.

        Returns:
            pd.DataFrame: Estimates dataframe with computed allocations added.
        &#34;&#34;&#34;
        self.calc_auth()
        if normalize:
            self.normalize()
        return self.estimates

    def calc_auth(self):
        &#34;&#34;&#34;
        Appends the allocated grants as columns to the estimates DataFrame.

        Must generate at least `true_grant_total` and `est_grant_total`.

        returns:
            pd.DataFrame: current estimates
        &#34;&#34;&#34;
        raise NotImplementedError

    def normalize(self):
        &#34;&#34;&#34;Normalize authorization amounts to allocation amounts.
        &#34;&#34;&#34;

    def adj_sppe(self):
        &#34;&#34;&#34;Calculate adjusted SPPE using Sonnenberg, 2016 pg. 18 algorithm.
        &#34;&#34;&#34;
        # Get baseline average across all 50 states and territories
        average = np.round(
            self.estimates.sppe.groupby(&#34;State FIPS Code&#34;).first().mean(),
            decimals=2
        )
        # Each state’s and each territory’s SPPE is multiplied by the
        # congressional cap and rounded to the second decimal place
        # (for dollars and cents).
        scaled = np.round(self.estimates.sppe * self.congress_cap, decimals=2)
        # No state recieves above/below the bounds set by law
        adj_sppe_trunc = scaled.clip(
            # bound by some % of the average, given in the law - round to cents
            *np.round(np.array(self.adj_sppe_bounds)*average, decimals=2)
        )
        adj_sppe_efig = scaled.clip(
            # bound %s are different for EFIG
            *np.round(np.array(self.adj_sppe_bounds_efig)*average, decimals=2)
        )
        return adj_sppe_trunc, adj_sppe_efig</code></pre>
</details>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dp_policy.titlei.allocators.AbowdAllocator" href="#dp_policy.titlei.allocators.AbowdAllocator">AbowdAllocator</a></li>
<li><a title="dp_policy.titlei.allocators.Authorizer" href="#dp_policy.titlei.allocators.Authorizer">Authorizer</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dp_policy.titlei.allocators.Allocator.adj_sppe"><code class="name flex">
<span>def <span class="ident">adj_sppe</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Calculate adjusted SPPE using Sonnenberg, 2016 pg. 18 algorithm.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L79-L100" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def adj_sppe(self):
    &#34;&#34;&#34;Calculate adjusted SPPE using Sonnenberg, 2016 pg. 18 algorithm.
    &#34;&#34;&#34;
    # Get baseline average across all 50 states and territories
    average = np.round(
        self.estimates.sppe.groupby(&#34;State FIPS Code&#34;).first().mean(),
        decimals=2
    )
    # Each state’s and each territory’s SPPE is multiplied by the
    # congressional cap and rounded to the second decimal place
    # (for dollars and cents).
    scaled = np.round(self.estimates.sppe * self.congress_cap, decimals=2)
    # No state recieves above/below the bounds set by law
    adj_sppe_trunc = scaled.clip(
        # bound by some % of the average, given in the law - round to cents
        *np.round(np.array(self.adj_sppe_bounds)*average, decimals=2)
    )
    adj_sppe_efig = scaled.clip(
        # bound %s are different for EFIG
        *np.round(np.array(self.adj_sppe_bounds_efig)*average, decimals=2)
    )
    return adj_sppe_trunc, adj_sppe_efig</code></pre>
</details>
</dd>
<dt id="dp_policy.titlei.allocators.Allocator.allocations"><code class="name flex">
<span>def <span class="ident">allocations</span></span>(<span>self, normalize: bool = False) ‑> pandas.core.frame.DataFrame</span>
</code></dt>
<dd>
<div class="desc"><p>Compute allocations.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>normalize</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Whether to normalize the authorization
amounts. Defaults to False.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.DataFrame</code></dt>
<dd>Estimates dataframe with computed allocations added.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L46-L62" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def allocations(
    self,
    normalize: bool = False
) -&gt; pd.DataFrame:
    &#34;&#34;&#34;Compute allocations.

    Args:
        normalize (bool, optional): Whether to normalize the authorization
            amounts. Defaults to False.

    Returns:
        pd.DataFrame: Estimates dataframe with computed allocations added.
    &#34;&#34;&#34;
    self.calc_auth()
    if normalize:
        self.normalize()
    return self.estimates</code></pre>
</details>
</dd>
<dt id="dp_policy.titlei.allocators.Allocator.calc_auth"><code class="name flex">
<span>def <span class="ident">calc_auth</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Appends the allocated grants as columns to the estimates DataFrame.</p>
<p>Must generate at least <code>true_grant_total</code> and <code>est_grant_total</code>.</p>
<p>returns:
pd.DataFrame: current estimates</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L64-L73" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def calc_auth(self):
    &#34;&#34;&#34;
    Appends the allocated grants as columns to the estimates DataFrame.

    Must generate at least `true_grant_total` and `est_grant_total`.

    returns:
        pd.DataFrame: current estimates
    &#34;&#34;&#34;
    raise NotImplementedError</code></pre>
</details>
</dd>
<dt id="dp_policy.titlei.allocators.Allocator.normalize"><code class="name flex">
<span>def <span class="ident">normalize</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Normalize authorization amounts to allocation amounts.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L75-L77" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def normalize(self):
    &#34;&#34;&#34;Normalize authorization amounts to allocation amounts.
    &#34;&#34;&#34;</code></pre>
</details>
</dd>
</dl>
</dd>
<dt id="dp_policy.titlei.allocators.Authorizer"><code class="flex name class">
<span>class <span class="ident">Authorizer</span></span>
<span>(</span><span>estimates: pandas.core.frame.DataFrame, prefixes: Tuple[str] = ('true', 'est', 'dp', 'dpest'), congress_cap: float = 0.4, adj_sppe_bounds: List[float] = [0.32, 0.48], adj_sppe_bounds_efig: List[float] = [0.34, 0.46], appropriation: float = None, verbose: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>An allocator that uses a normalization strategy to convert
authorization amounts to allocation amounts.</p>
<p>Class for allocating Title I funds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The poverty estimates, including
randomized estimates.</dd>
<dt><strong><code>prefixes</code></strong> :&ensp;<code>Tuple[str]</code>, optional</dt>
<dd>Prefixes for different kinds of
estimates. Defaults to ("true", "est", "dp", "dpest").</dd>
<dt><strong><code>congress_cap</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Congressional cap. Defaults to 0.4.</dd>
<dt><strong><code>adj_sppe_bounds</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted SPPE.
Defaults to [0.32, 0.48].</dd>
<dt><strong><code>adj_sppe_bounds_efig</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted
SPPE for EFIG grants. Defaults to [0.34, 0.46].</dd>
<dt><strong><code>appropriation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total congressional appropriation.
Defaults to None.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L123-L351" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class Authorizer(Allocator):
    &#34;&#34;&#34;An allocator that uses a normalization strategy to convert
    authorization amounts to allocation amounts.
    &#34;&#34;&#34;
    def grant_types(self):
        raise NotImplementedError

    def calc_total(self):
        for prefix in self.prefixes:
            self.estimates[f&#34;{prefix}_grant_total&#34;] = self.estimates[[
                f&#34;{prefix}_grant_{grant_type}&#34;
                for grant_type in self.grant_types()
            ]].sum(axis=1)
        return self.estimates

    def allocations(
        self, normalize=True, **kwargs
    ) -&gt; pd.DataFrame:
        super().allocations(**kwargs)
        if normalize:
            for grant_type in self.grant_types():
                for prefix in self.prefixes:
                    appropriation = \
                        self._calc_appropriation_total(grant_type)
                    self._normalize(grant_type, prefix, appropriation)
            self.calc_total()
            if self.verbose:
                total_approp = self.estimates[[
                    f&#34;official_{grant_type}_alloc&#34;
                    for grant_type in self.grant_types()
                ]].sum().sum()
                print(
                    &#34;After normalization, appropriation is&#34;,
                    total_approp,
                    &#34;and true allocation is&#34;,
                    self.estimates.true_grant_total.sum()
                )
        return self.estimates

    def _calc_appropriation_total(
        self,
        grant_type: str
    ) -&gt; float:
        &#34;&#34;&#34;Using official figures, calculate appropriation for this grant type.

        Args:
            grant_type (str): The grant type. One of &#34;basic&#34;, &#34;concentration&#34;,
                &#34;targeted&#34;.

        Returns:
            float: The total appropration for this grant type.
        &#34;&#34;&#34;
        appropriation = self.estimates[f&#34;official_{grant_type}_alloc&#34;].sum()
        if self.appropriation_total is not None:
            if self.verbose:
                print(&#34;Usual appropriation:&#34;, appropriation)
                print(
                    &#34;Usual total:&#34;,
                    self.estimates[f&#34;official_total_alloc&#34;].sum()
                )
                print(
                    self.appropriation_total /
                    self.estimates[f&#34;official_total_alloc&#34;].sum()
                )
                print(&#34;New appropriation:&#34;, (
                    appropriation * self.appropriation_total /
                    self.estimates[f&#34;official_total_alloc&#34;].sum()
                ))
            # scale appropriation to total budget
            return (
                appropriation * self.appropriation_total /
                self.estimates[f&#34;official_total_alloc&#34;].sum()
            )
        return appropriation

    def _normalize(
        self,
        grant_type: str,
        prefix: str,
        appropriation: float,
        hold_harmless: pd.Series = None,
        state_minimum: bool = False
    ):
        &#34;&#34;&#34;Normalize funding amounts, honoring special provisions.

        Args:
            grant_type (str):  The grant type. One of &#34;basic&#34;, &#34;concentration&#34;,
                &#34;targeted&#34;.
            prefix (str): Prefix for estimate. One of
                (&#34;true&#34;, &#34;est&#34;, &#34;dp&#34;, &#34;dpest&#34;).
            appropriation (float): The total appropriation available.
            hold_harmless (pd.DataFrame, optional): If provided, which
                districts are held harmless. Defaults to None.
            state_minimum (bool, optional): Whether to apply the state minimum.
                Defaults to False.
        &#34;&#34;&#34;
        if hold_harmless is None:
            hold_harmless = np.zeros(len(self.estimates)).astype(bool)

        current_budget = \
            self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;].sum()

        # do a round of hold harmless normalization
        # (to get the alloc instead of auth amounts)
        self._normalize_segment(
                np.ones(len(self.estimates)).astype(bool),
                hold_harmless,
                grant_type, prefix,
                appropriation
            )

        if state_minimum:
            glob_min = \
                SonnenbergAuthorizer._state_minimum_global(grant_type)
            formula_children = self.estimates[f&#34;{prefix}_children_eligible&#34;]\
                .where(
                    self.estimates[f&#34;{prefix}_eligible_{grant_type}&#34;],
                    0
                )
            state_eligible = formula_children\
                .groupby(&#34;State FIPS Code&#34;).transform(&#39;sum&#39;)
            # nat&#39;l avg per-pupil payment (???)
            napp = appropriation \
                / self.estimates[f&#34;{prefix}_children_total&#34;].sum()
            eligib_comp = state_eligible * 1.5 * napp
            if grant_type == &#34;concentration&#34;:
                # for concentration, this amount is at minimum 340000
                eligib_comp = np.clip(eligib_comp, 340000, None)

            # the state minimum is the smaller of
            state_minimums = np.minimum(
                # 1) the global minimum - derived from the official
                # FY 2021 state allocs
                np.ones(len(self.estimates)) * glob_min,
                # and 2) the average of
                1/2 * (
                    # a) global minimum and
                    # b) the state&#39;s elibility count * 1.5 * avg SPPE
                    glob_min + eligib_comp
                )
            )
            # identify LEAs in states under the minimum
            under_minimum = self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;]\
                .groupby(&#34;State FIPS Code&#34;).transform(&#39;sum&#39;) &lt; state_minimums
            if self.verbose:
                print(
                    &#34;These states meet the state minimum:&#34;,
                    np.unique(
                        under_minimum[under_minimum].index
                        .get_level_values(&#34;State FIPS Code&#34;).values
                    )
                )

            # first, normalize all the over-minimum states
            total_minimum = state_minimums[under_minimum]\
                .groupby(&#34;State FIPS Code&#34;).first().sum()
            self._normalize_segment(
                ~under_minimum,
                hold_harmless,
                grant_type, prefix,
                appropriation - total_minimum
            )

            # then normalize the under-minimum states, state-by-state
            for _, group in self.estimates[under_minimum].groupby(
                &#34;State FIPS Code&#34;
            ):
                minimum = state_minimums[group.index].iloc[0]
                self._normalize_segment(
                    self.estimates.index.isin(group.index),
                    hold_harmless,
                    grant_type, prefix,
                    minimum
                )

        if self.verbose:
            print(
                f&#34;{current_budget} authorized for {grant_type} reduced &#34;
                f&#34;to {appropriation} allocated.&#34;
            )

    def _normalize_segment(
        self,
        segment: pd.Series,
        hold_harmless: pd.Series,
        grant_type: str,
        prefix: str,
        segment_appropriation: float
    ):
        &#34;&#34;&#34;Normalize the budget for a segment of the districts.

        Args:
            segment (pd.Series): A boolean mask indicating the segment to
                normalize.
            hold_harmless (pd.Series): Which districts should be held harmless.
            grant_type (str): Grant type to normalize.
            prefix (str): Which treatment to normalize (generally &#34;true&#34;,
                &#34;est&#34; or &#34;dpest&#34;).
            segment_appropriation (float): The total budget for this segment.
        &#34;&#34;&#34;
        # available budget is the full budget minus hold harmless districts
        remaining_budget = segment_appropriation - self.estimates.loc[
                segment &amp; hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
            ].sum()
        # redistribute the remaining budget between non-harmless districts
        self.estimates.loc[
            segment &amp; ~hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
        ] = \
            Authorizer.normalize_to_budget(
                self.estimates.loc[
                    segment &amp; ~hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
                ], remaining_budget
            )

    @staticmethod
    def normalize_to_budget(
        authorizations: pd.Series,
        total_budget: int
    ) -&gt; pd.Series:
        &#34;&#34;&#34;Scale authorizations proportional to total federal budget.

        Args:
            authorizations (pd.Series): Authorization amounts.
            total_budget (int): Estimated total budget for Title I this year.

        Returns:
            pd.Series: Normalized authorization amounts.
        &#34;&#34;&#34;
        return authorizations / authorizations.sum() * total_budget</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dp_policy.titlei.allocators.Allocator" href="#dp_policy.titlei.allocators.Allocator">Allocator</a></li>
</ul>
<h3>Subclasses</h3>
<ul class="hlist">
<li><a title="dp_policy.titlei.allocators.SonnenbergAuthorizer" href="#dp_policy.titlei.allocators.SonnenbergAuthorizer">SonnenbergAuthorizer</a></li>
</ul>
<h3>Static methods</h3>
<dl>
<dt id="dp_policy.titlei.allocators.Authorizer.normalize_to_budget"><code class="name flex">
<span>def <span class="ident">normalize_to_budget</span></span>(<span>authorizations: pandas.core.series.Series, total_budget: int) ‑> pandas.core.series.Series</span>
</code></dt>
<dd>
<div class="desc"><p>Scale authorizations proportional to total federal budget.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>authorizations</code></strong> :&ensp;<code>pd.Series</code></dt>
<dd>Authorization amounts.</dd>
<dt><strong><code>total_budget</code></strong> :&ensp;<code>int</code></dt>
<dd>Estimated total budget for Title I this year.</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>pd.Series</code></dt>
<dd>Normalized authorization amounts.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L337-L351" class="git-link">Browse git</a>
</summary>
<pre><code class="python">@staticmethod
def normalize_to_budget(
    authorizations: pd.Series,
    total_budget: int
) -&gt; pd.Series:
    &#34;&#34;&#34;Scale authorizations proportional to total federal budget.

    Args:
        authorizations (pd.Series): Authorization amounts.
        total_budget (int): Estimated total budget for Title I this year.

    Returns:
        pd.Series: Normalized authorization amounts.
    &#34;&#34;&#34;
    return authorizations / authorizations.sum() * total_budget</code></pre>
</details>
</dd>
</dl>
<h3>Methods</h3>
<dl>
<dt id="dp_policy.titlei.allocators.Authorizer.calc_total"><code class="name flex">
<span>def <span class="ident">calc_total</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L130-L136" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def calc_total(self):
    for prefix in self.prefixes:
        self.estimates[f&#34;{prefix}_grant_total&#34;] = self.estimates[[
            f&#34;{prefix}_grant_{grant_type}&#34;
            for grant_type in self.grant_types()
        ]].sum(axis=1)
    return self.estimates</code></pre>
</details>
</dd>
<dt id="dp_policy.titlei.allocators.Authorizer.grant_types"><code class="name flex">
<span>def <span class="ident">grant_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L127-L128" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grant_types(self):
    raise NotImplementedError</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dp_policy.titlei.allocators.Allocator" href="#dp_policy.titlei.allocators.Allocator">Allocator</a></b></code>:
<ul class="hlist">
<li><code><a title="dp_policy.titlei.allocators.Allocator.adj_sppe" href="#dp_policy.titlei.allocators.Allocator.adj_sppe">adj_sppe</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.allocations" href="#dp_policy.titlei.allocators.Allocator.allocations">allocations</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.calc_auth" href="#dp_policy.titlei.allocators.Allocator.calc_auth">calc_auth</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.normalize" href="#dp_policy.titlei.allocators.Allocator.normalize">normalize</a></code></li>
</ul>
</li>
</ul>
</dd>
<dt id="dp_policy.titlei.allocators.SonnenbergAuthorizer"><code class="flex name class">
<span>class <span class="ident">SonnenbergAuthorizer</span></span>
<span>(</span><span>*args, **kwargs)</span>
</code></dt>
<dd>
<div class="desc"><p>Authorizer allocator described by Sonnenberg (2007). Official process
used by Dep Ed.</p>
<p>Class for allocating Title I funds.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>estimates</code></strong> :&ensp;<code>pd.DataFrame</code></dt>
<dd>The poverty estimates, including
randomized estimates.</dd>
<dt><strong><code>prefixes</code></strong> :&ensp;<code>Tuple[str]</code>, optional</dt>
<dd>Prefixes for different kinds of
estimates. Defaults to ("true", "est", "dp", "dpest").</dd>
<dt><strong><code>congress_cap</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Congressional cap. Defaults to 0.4.</dd>
<dt><strong><code>adj_sppe_bounds</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted SPPE.
Defaults to [0.32, 0.48].</dd>
<dt><strong><code>adj_sppe_bounds_efig</code></strong> :&ensp;<code>List[float]</code>, optional</dt>
<dd>Bounds on adjusted
SPPE for EFIG grants. Defaults to [0.34, 0.46].</dd>
<dt><strong><code>appropriation</code></strong> :&ensp;<code>float</code>, optional</dt>
<dd>Total congressional appropriation.
Defaults to None.</dd>
<dt><strong><code>verbose</code></strong> :&ensp;<code>bool</code>, optional</dt>
<dd>Defaults to False.</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L354-L646" class="git-link">Browse git</a>
</summary>
<pre><code class="python">class SonnenbergAuthorizer(Authorizer):
    &#34;&#34;&#34;Authorizer allocator described by Sonnenberg (2007). Official process
    used by Dep Ed.
    &#34;&#34;&#34;
    def __init__(
        self,
        *args,
        **kwargs
    ):
        self.hold_harmless = kwargs.pop(&#39;hold_harmless&#39;, False)
        self.state_minimum = kwargs.pop(&#39;state_minimum&#39;, False)
        self.thresholder = kwargs.pop(&#39;thresholder&#39;, HardThresholder())
        super().__init__(*args, **kwargs)
        if self.state_minimum and self.verbose:
            print(
                &#34;[WARN] State minimum works using 2021 data. &#34;
                &#34;Will be wrong for earlier years.&#34;
            )

    def allocations(
        self, **kwargs
    ) -&gt; pd.DataFrame:
        super().allocations(**kwargs)
        if self.hold_harmless or self.state_minimum:
            self._provisions()
        return self.estimates

    def grant_types(self):
        return (
            &#34;basic&#34;,
            &#34;concentration&#34;,
            &#34;targeted&#34;
        )

    def calc_auth(self):
        # calc adj. SPPE
        adj_sppe, _ = self.adj_sppe()
        self.thresholder.set_cv(self.estimates.cv)

        # calculate grant amounts for true/randomized values
        for prefix in self.prefixes:
            # BASIC GRANTS
            # authorization calculation
            self.estimates[f&#34;{prefix}_grant_basic&#34;] = \
                self.estimates[f&#34;{prefix}_children_eligible&#34;] * adj_sppe
            # For basic grants, LEA must have
            # &gt;10 eligible children
            # AND &gt;2% eligible
            grants, eligible = \
                self.thresholder.process(
                    self.estimates[f&#34;{prefix}_grant_basic&#34;],
                    self.estimates[f&#34;{prefix}_children_eligible&#34;],
                    self.estimates[f&#34;{prefix}_children_total&#34;],
                    [
                        Threshold(10, prop=False),
                        Threshold(0.02, prop=True)
                    ],
                    comb_func=np.logical_and.reduce
                )
            self.estimates.loc[:, f&#34;{prefix}_grant_basic&#34;] = grants
            self.estimates.loc[:, f&#34;{prefix}_eligible_basic&#34;] = eligible

            # CONCENTRATION GRANTS
            # For concentration grants, LEAs must meet basic eligibility
            # AND have either
            # a) &gt;6500 eligible
            # b) 15% of pop. is eligible
            self.estimates[f&#34;{prefix}_grant_concentration&#34;] = \
                self.estimates[f&#34;{prefix}_grant_basic&#34;]
            grants, eligible = \
                self.thresholder.process(
                    self.estimates[f&#34;{prefix}_grant_concentration&#34;],
                    self.estimates[f&#34;{prefix}_children_eligible&#34;],
                    self.estimates[f&#34;{prefix}_children_total&#34;],
                    [
                        Threshold(6500, prop=False),
                        Threshold(0.15, prop=True)
                    ],
                    comb_func=lambda x:
                        self.estimates[f&#34;{prefix}_eligible_basic&#34;]
                        &amp; np.logical_or.reduce(x)
                )
            self.estimates.loc[:, f&#34;{prefix}_grant_concentration&#34;] = grants
            self.estimates.loc[:, f&#34;{prefix}_eligible_concentration&#34;] = \
                eligible

            # TARGETED GRANTS
            # weighted by an exogenous step function - see documentation
            weighted_eligible = self.estimates[[
                f&#34;{prefix}_children_eligible&#34;, f&#34;{prefix}_children_total&#34;
            ]].apply(
                lambda x: weighting(x[0], x[1]),
                axis=1
            )
            self.estimates[
                f&#34;{prefix}_grant_targeted&#34;
            ] = weighted_eligible * adj_sppe
            # for targeted grants, LEAs must:
            # meet basic eligibility AND have &gt;5% eligible
            grants, eligible = \
                self.thresholder.process(
                    self.estimates[f&#34;{prefix}_grant_targeted&#34;],
                    self.estimates[f&#34;{prefix}_children_eligible&#34;],
                    self.estimates[f&#34;{prefix}_children_total&#34;],
                    [
                        Threshold(10, prop=False),
                        Threshold(0.05, prop=True)
                    ],
                    comb_func=np.logical_and.reduce
                )
            self.estimates.loc[:, f&#34;{prefix}_grant_targeted&#34;] = grants
            self.estimates.loc[:, f&#34;{prefix}_eligible_targeted&#34;] = eligible

            # EFIG
            # TODO

            # clip lower bound to zero
            for grant_type in [&#34;basic&#34;, &#34;concentration&#34;, &#34;targeted&#34;]:
                self.estimates.loc[
                    self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;] &lt; 0.0,
                    f&#34;{prefix}_grant_{grant_type}&#34;
                ] = 0.0

        self.calc_total()

    def _provisions(self):
        &#34;&#34;&#34;
        Apply post-formula provisions (hold harmless and state minimum).
        Achieved by recursively updating allocations until all provisions are
        satisfied.
        &#34;&#34;&#34;
        if self.verbose:
            if self.hold_harmless:
                print(&#34;Applying hold harmless&#34;)
            if self.state_minimum:
                print(&#34;Applying state minimum&#34;)

        # load last year&#39;s allocs - watch out for endogeneity
        # get this year&#39;s budget
        for grant_type in self.grant_types():
            alloc_previous = \
                self.estimates[f&#34;official_{grant_type}_hold_harmless&#34;]
            appropriation = self._calc_appropriation_total(grant_type)
            for prefix in self.prefixes:
                # hold harmless
                self._harmless_rate = SonnenbergAuthorizer._hold_harmless_rate(
                    self.estimates[f&#34;{prefix}_children_eligible&#34;] /
                    self.estimates[f&#34;{prefix}_children_total&#34;]
                )
                self._provisions_recursive(
                    0,
                    prefix,
                    grant_type,
                    appropriation,
                    alloc_previous
                )

        self.calc_total()
        if self.verbose:
            total_approp = self.estimates[[
                f&#34;official_{grant_type}_alloc&#34;
                for grant_type in self.grant_types()
            ]].sum().sum()
            print(
                &#34;After provision(s), appropriation is&#34;,
                total_approp,
                &#34;and true allocation is&#34;,
                self.estimates.true_grant_total.sum()
            )

    def _provisions_recursive(
        self,
        depth: int,
        prefix: str,
        grant_type: str,
        appropriation: float,
        alloc_previous: pd.Series,
        held_harmless: bool = None,
        max_depth: int = 10
    ):
        &#34;&#34;&#34;Apply one iteration of post-formula provisions.

        Args:
            depth (int): Current iteration of recursion.
            prefix (str): Prefix of allocation to adjust.
            grant_type (str): Grant type to adjust.
            appropriation (float): Appropriation for this grant type.
            alloc_previous (pd.Series): Previous year&#39;s allocations.
            held_harmless (bool, optional): Boolena mask for districts to hold
                harmless. Defaults to None.
            max_depth (int, optional): Maximum number of iterations to run
                before stopping. Defaults to 10.
        &#34;&#34;&#34;
        # assume no LEAs in violation of provisions
        leas_in_violation = np.zeros(len(self.estimates)).astype(bool)

        if self.hold_harmless:
            if held_harmless is None:
                held_harmless = np.zeros(len(self.estimates)).astype(bool)
            # identify LEAs suffering excessive harm
            hold_harmless = self._excessive_loss(
                prefix, grant_type, alloc_previous, self._harmless_rate
            )
            if self.verbose and depth &gt; 0:
                print(
                    &#34;Hold harmless iter&#34;, depth,
                    f&#34;- {hold_harmless.sum()} hold harm districts remaining&#34;
                )
            # limit losses to the appropriate harmless rate
            if hold_harmless.any():
                held_harmless = held_harmless | hold_harmless
                leas_in_violation = leas_in_violation | hold_harmless
                self.estimates.loc[
                    hold_harmless, f&#34;{prefix}_grant_{grant_type}&#34;
                ] = alloc_previous * self._harmless_rate
                self._normalize(
                    grant_type, prefix, appropriation,
                    hold_harmless=held_harmless,
                    state_minimum=self.state_minimum
                )
        else:
            self._normalize(
                grant_type, prefix, appropriation,
                state_minimum=self.state_minimum
            )

        # once no LEAs are in violation, finish
        if not leas_in_violation.any():
            return

        if depth &gt;= max_depth:
            if self.hold_harmless:
                print(f&#34;[WARN]: {hold_harmless.sum()} not held harmless.&#34;)
            print(
                f&#34;[WARN] Could not converge after {max_depth} iterations.&#34;
            )
            return

        return self._provisions_recursive(
            depth+1,
            prefix,
            grant_type,
            appropriation,
            alloc_previous,
            held_harmless=held_harmless,
            max_depth=max_depth
        )

    def _excessive_loss(
        self,
        prefix: str,
        grant_type: str,
        alloc_previous: pd.Series,
        harmless_rate: pd.Series
    ) -&gt; pd.Series:
        &#34;&#34;&#34;Determine whether a district has suffered excessive loss.

        Returns:
            pd.Series: Boolean mask for each district indicating whether it
                has suffered excessive loss compared to the previous
                year&#39;s allocation.
        &#34;&#34;&#34;
        return (
            self.estimates[f&#34;{prefix}_grant_{grant_type}&#34;] &lt;
            harmless_rate * alloc_previous
        )

    @staticmethod
    def _hold_harmless_rate(prop_eligible: pd.Series) -&gt; np.ndarray:
        &#34;&#34;&#34;Determine the hold harmless rate for a district based on the
        proportion of eligible children.
        &#34;&#34;&#34;
        return np.where(
            prop_eligible &lt; 0.15,
            0.85,
            np.where(
                prop_eligible &lt; 0.3,
                0.9,
                0.95
            )
        )

    @staticmethod
    def _state_minimum_global(grant_type: str) -&gt; int:
        # drawing this manually from the FY 2021 state-level data
        # NOTE: only works for 2021 data
        if grant_type == &#34;basic&#34;:
            return 17744098
        if grant_type == &#34;concentration&#34;:
            return 3378479
        if grant_type == &#34;targeted&#34;:
            return 15083659
        raise ValueError(f&#34;Unmatched grant type: {grant_type}&#34;)</code></pre>
</details>
<h3>Ancestors</h3>
<ul class="hlist">
<li><a title="dp_policy.titlei.allocators.Authorizer" href="#dp_policy.titlei.allocators.Authorizer">Authorizer</a></li>
<li><a title="dp_policy.titlei.allocators.Allocator" href="#dp_policy.titlei.allocators.Allocator">Allocator</a></li>
</ul>
<h3>Methods</h3>
<dl>
<dt id="dp_policy.titlei.allocators.SonnenbergAuthorizer.grant_types"><code class="name flex">
<span>def <span class="ident">grant_types</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"></div>
<details class="source">
<summary>
<span>Expand source code</span>
<a href="https://github.com/ryansteed/dp-policy/blob/cd30e376bcd1ca5ea021175103bba1e324ff2447/dp_policy/titlei/allocators.py#L381-L386" class="git-link">Browse git</a>
</summary>
<pre><code class="python">def grant_types(self):
    return (
        &#34;basic&#34;,
        &#34;concentration&#34;,
        &#34;targeted&#34;
    )</code></pre>
</details>
</dd>
</dl>
<h3>Inherited members</h3>
<ul class="hlist">
<li><code><b><a title="dp_policy.titlei.allocators.Authorizer" href="#dp_policy.titlei.allocators.Authorizer">Authorizer</a></b></code>:
<ul class="hlist">
<li><code><a title="dp_policy.titlei.allocators.Authorizer.adj_sppe" href="#dp_policy.titlei.allocators.Allocator.adj_sppe">adj_sppe</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Authorizer.allocations" href="#dp_policy.titlei.allocators.Allocator.allocations">allocations</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Authorizer.calc_auth" href="#dp_policy.titlei.allocators.Allocator.calc_auth">calc_auth</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Authorizer.normalize" href="#dp_policy.titlei.allocators.Allocator.normalize">normalize</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Authorizer.normalize_to_budget" href="#dp_policy.titlei.allocators.Authorizer.normalize_to_budget">normalize_to_budget</a></code></li>
</ul>
</li>
</ul>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="dp_policy.titlei" href="index.html">dp_policy.titlei</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="dp_policy.titlei.allocators.AbowdAllocator" href="#dp_policy.titlei.allocators.AbowdAllocator">AbowdAllocator</a></code></h4>
<ul class="">
<li><code><a title="dp_policy.titlei.allocators.AbowdAllocator.grant_types" href="#dp_policy.titlei.allocators.AbowdAllocator.grant_types">grant_types</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dp_policy.titlei.allocators.Allocator" href="#dp_policy.titlei.allocators.Allocator">Allocator</a></code></h4>
<ul class="">
<li><code><a title="dp_policy.titlei.allocators.Allocator.adj_sppe" href="#dp_policy.titlei.allocators.Allocator.adj_sppe">adj_sppe</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.allocations" href="#dp_policy.titlei.allocators.Allocator.allocations">allocations</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.calc_auth" href="#dp_policy.titlei.allocators.Allocator.calc_auth">calc_auth</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Allocator.normalize" href="#dp_policy.titlei.allocators.Allocator.normalize">normalize</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dp_policy.titlei.allocators.Authorizer" href="#dp_policy.titlei.allocators.Authorizer">Authorizer</a></code></h4>
<ul class="">
<li><code><a title="dp_policy.titlei.allocators.Authorizer.calc_total" href="#dp_policy.titlei.allocators.Authorizer.calc_total">calc_total</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Authorizer.grant_types" href="#dp_policy.titlei.allocators.Authorizer.grant_types">grant_types</a></code></li>
<li><code><a title="dp_policy.titlei.allocators.Authorizer.normalize_to_budget" href="#dp_policy.titlei.allocators.Authorizer.normalize_to_budget">normalize_to_budget</a></code></li>
</ul>
</li>
<li>
<h4><code><a title="dp_policy.titlei.allocators.SonnenbergAuthorizer" href="#dp_policy.titlei.allocators.SonnenbergAuthorizer">SonnenbergAuthorizer</a></code></h4>
<ul class="">
<li><code><a title="dp_policy.titlei.allocators.SonnenbergAuthorizer.grant_types" href="#dp_policy.titlei.allocators.SonnenbergAuthorizer.grant_types">grant_types</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>